{"version":3,"sources":["webpack:///responsive-lazyload.min.js","webpack:///webpack/bootstrap 05aeede86c3a2b9c49e2","webpack:///./source/scripts/responsive-lazyload.browser.js","webpack:///./source/scripts/responsive-lazyload.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_responsiveLazyload","window","responsiveLazyload","lazyLoadImages","isElementVisible","el","isCurrentlyVisible","offsetParent","position","getBoundingClientRect","wHeight","innerHeight","document","documentElement","clientHeight","isWithinViewport","top","bottom","throttle","func","limit","arguments","length","undefined","wait","setTimeout","config","createElement","initialize","maybeTriggerImageLoad","image","event","getAttribute","dispatchEvent","findImageElement","container","tag","tagName","toLowerCase","querySelector","loadImage","target","srcset","setAttribute","removeLoadingClass","loadingClass","element","shouldReturn","classList","contains","remove","parentNode","checkForImagesToLazyLoad","lazyLoadEvent","images","forEach","_ref","_ref$containerClass","containerClass","_ref$loadingClass","_ref$callback","callback","containers","getElementsByClassName","add","map","Event","addEventListener","loadVisibleImages","bind","scrollHandler","default"],"mappings":"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","file":"responsive-lazyload.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _responsiveLazyload = __webpack_require__(1);\n\n// Create a global for access without using webpack.\nwindow.responsiveLazyload = { lazyLoadImages: _responsiveLazyload.lazyLoadImages };\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyLoadImages = lazyLoadImages;\n/**\n * Check if an element is visible at all in the viewport.\n *\n * It would be cool to use an IntersectionObserver here, but browser support\n * isn’t there yet: http://caniuse.com/#feat=intersectionobserver\n *\n * @param  {Element} el the element to check\n * @return {Boolean}    `true` if the element is visible at all; `false` if not\n */\nfunction isElementVisible(el) {\n  /*\n   * Checks if element (or an ancestor) is hidden via style properties.\n   * See https://stackoverflow.com/a/21696585/463471\n   */\n  var isCurrentlyVisible = el.offsetParent !== null;\n\n  // Check if any part of the element is vertically within the viewport.\n  var position = el.getBoundingClientRect();\n  var wHeight = window.innerHeight || document.documentElement.clientHeight;\n  var isWithinViewport = position.top >= 0 && position.top <= wHeight || position.bottom >= 0 && position.bottom <= wHeight;\n\n  return isCurrentlyVisible && isWithinViewport;\n}\n\n/**\n * Prevents a function from firing too often.\n * @param  {Function} func  the function to throttle\n * @param  {Number}   limit the amount of milliseconds to wait between calls\n * @return {Function}       function to check if the function should be called\n */\nfunction throttle(func) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n\n  var wait = false;\n\n  return function () {\n    if (!wait) {\n      func.call();\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n      }, limit);\n    }\n  };\n}\n\n/**\n * Check if an image is visible and trigger an event if so.\n * @param  {Element} image the image to check\n * @param  {Event}   event an event to dispatch if the image is in the viewport\n * @return {Boolean}       true if the image is in the viewport; false if not\n */\nvar maybeTriggerImageLoad = function maybeTriggerImageLoad(image, event) {\n  if (!image.getAttribute('data-loaded') && isElementVisible(image)) {\n    image.dispatchEvent(event);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Finds the image to be lazyloaded.\n * @param  {Element} container `img` element to be lazyloaded or its container\n * @return {Element}           the `img` element to be lazyloaded\n */\nvar findImageElement = function findImageElement(container) {\n  var tag = container.tagName.toLowerCase();\n\n  return tag === 'img' ? container : container.querySelector('img');\n};\n\n/**\n * This almost seems too easy, but we simply swap in the correct srcset.\n * @param  {Event} event the triggered event\n * @return {Void}\n */\nvar loadImage = function loadImage(event) {\n  var image = event.target;\n\n  // Swap in the srcset info and add an attribute to prevent duplicate loads.\n  image.srcset = image.getAttribute('data-lazyload');\n  image.setAttribute('data-loaded', true);\n};\n\n/**\n * Remove the loading class from the lazyload wrapper.\n * @param  {Element} image        the image being loaded\n * @param  {String}  loadingClass the class to remove\n * @return {Void}\n */\nvar removeLoadingClass = function removeLoadingClass(image, loadingClass) {\n  var element = image;\n  var shouldReturn = false;\n\n  /*\n   * Since there may be additional elements wrapping the image (e.g. a link),\n   * we run a loop to check the image’s ancestors until we either find the\n   * element with the loading class or hit the `body` element.\n   */\n  while (element.tagName.toLowerCase() !== 'body') {\n    if (element.classList.contains(loadingClass)) {\n      element.classList.remove(loadingClass);\n      shouldReturn = true;\n    } else {\n      element = element.parentNode;\n    }\n\n    if (shouldReturn) {\n      return;\n    }\n  }\n};\n\nvar checkForImagesToLazyLoad = function checkForImagesToLazyLoad(lazyLoadEvent, images) {\n  images.forEach(function (image) {\n    maybeTriggerImageLoad(image, lazyLoadEvent);\n  });\n};\n\n/**\n * Initializes the lazyloader and adds the relevant classes and handlers.\n * @param  {String}   options.containerClass the lazyloaded image wrapper\n * @param  {String}   options.loadingClass   the class that signifies loading\n * @param  {Function} options.callback       a function to fire on image load\n * @return {Function}                        a function to load visible images\n */\nvar initialize = function initialize() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$containerClass = _ref.containerClass,\n      containerClass = _ref$containerClass === undefined ? 'js--lazyload' : _ref$containerClass,\n      _ref$loadingClass = _ref.loadingClass,\n      loadingClass = _ref$loadingClass === undefined ? 'js--lazyload--loading' : _ref$loadingClass,\n      _ref$callback = _ref.callback,\n      callback = _ref$callback === undefined ? false : _ref$callback;\n\n  // Find all the containers and add the loading class.\n  var containers = document.getElementsByClassName(containerClass);\n\n  [].forEach.call(containers, function (container) {\n    container.classList.add(loadingClass);\n  });\n\n  // If we get here, `srcset` is supported and we can start processing things.\n  var images = [].map.call(containers, findImageElement);\n\n  // Create a custom event to trigger the event load.\n  var lazyLoadEvent = new Event('lazyload-init');\n\n  // Attach an onload handler to each image.\n  images.forEach(function (image) {\n    /*\n     * Once the image is loaded, we want to remove the loading class so any\n     * loading animations or other effects can be disabled.\n     */\n    image.addEventListener('load', function (event) {\n      removeLoadingClass(event.target, loadingClass);\n\n      // If a callback was provided, fire it.\n      if (typeof callback === 'function') {\n        callback(event);\n      }\n    });\n\n    /*\n     * Set up a listener for the custom event that triggers the image load\n     * handler (which loads the image).\n     */\n    image.addEventListener('lazyload-init', loadImage);\n\n    /*\n     * Check if the image is already in the viewport. If so, load it.\n     */\n    maybeTriggerImageLoad(image, lazyLoadEvent);\n  });\n\n  var loadVisibleImages = checkForImagesToLazyLoad.bind(null, lazyLoadEvent, images);\n\n  /*\n   * Add an event listener when the page is scrolled. To avoid bogging down the\n   * page, we throttle this call to only run every 100ms.\n   */\n  var scrollHandler = throttle(loadVisibleImages, 100);\n  window.addEventListener('scroll', scrollHandler);\n\n  // Return a function to allow manual checks for images to lazy load.\n  return loadVisibleImages;\n};\n\n/**\n * The public function to initialize lazyloading\n * @param  {Object} config configuration options (see `initialize()`)\n * @return {Function}      a function to manually check for images to lazy load\n */\nfunction lazyLoadImages() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // If we have `srcset` support, initialize the lazyloader.\n  if ('srcset' in document.createElement('img')) {\n    return initialize(config);\n  }\n}\n\nexports.default = {\n  lazyLoadImages: lazyLoadImages\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// responsive-lazyload.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 05aeede86c3a2b9c49e2","import { lazyLoadImages } from './responsive-lazyload';\n\n// Create a global for access without using webpack.\nwindow.responsiveLazyload = { lazyLoadImages };\n\n\n\n// WEBPACK FOOTER //\n// ./source/scripts/responsive-lazyload.browser.js","/**\n * Check if an element is visible at all in the viewport.\n *\n * It would be cool to use an IntersectionObserver here, but browser support\n * isn’t there yet: http://caniuse.com/#feat=intersectionobserver\n *\n * @param  {Element} el the element to check\n * @return {Boolean}    `true` if the element is visible at all; `false` if not\n */\nfunction isElementVisible(el) {\n  /*\n   * Checks if element (or an ancestor) is hidden via style properties.\n   * See https://stackoverflow.com/a/21696585/463471\n   */\n  const isCurrentlyVisible = el.offsetParent !== null;\n\n  // Check if any part of the element is vertically within the viewport.\n  const position = el.getBoundingClientRect();\n  const wHeight = window.innerHeight || document.documentElement.clientHeight;\n  const isWithinViewport = (\n    (position.top >= 0 && position.top <= wHeight) ||\n    (position.bottom >= 0 && position.bottom <= wHeight)\n  );\n\n  return isCurrentlyVisible && isWithinViewport;\n}\n\n/**\n * Prevents a function from firing too often.\n * @param  {Function} func  the function to throttle\n * @param  {Number}   limit the amount of milliseconds to wait between calls\n * @return {Function}       function to check if the function should be called\n */\nfunction throttle(func, limit = 200) {\n  let wait = false;\n\n  return () => {\n    if (!wait) {\n      func.call();\n      wait = true;\n      setTimeout(() => {\n        wait = false;\n      }, limit);\n    }\n  };\n}\n\n/**\n * Check if an image is visible and trigger an event if so.\n * @param  {Element} image the image to check\n * @param  {Event}   event an event to dispatch if the image is in the viewport\n * @return {Boolean}       true if the image is in the viewport; false if not\n */\nconst maybeTriggerImageLoad = (image, event) => {\n  if (!image.getAttribute('data-loaded') && isElementVisible(image)) {\n    image.dispatchEvent(event);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Finds the image to be lazyloaded.\n * @param  {Element} container `img` element to be lazyloaded or its container\n * @return {Element}           the `img` element to be lazyloaded\n */\nconst findImageElement = (container) => {\n  const tag = container.tagName.toLowerCase();\n\n  return tag === 'img' ? container : container.querySelector('img');\n};\n\n/**\n * This almost seems too easy, but we simply swap in the correct srcset.\n * @param  {Event} event the triggered event\n * @return {Void}\n */\nconst loadImage = (event) => {\n  const image = event.target;\n\n  // Swap in the srcset info and add an attribute to prevent duplicate loads.\n  image.srcset = image.getAttribute('data-lazyload');\n  image.setAttribute('data-loaded', true);\n};\n\n/**\n * Remove the loading class from the lazyload wrapper.\n * @param  {Element} image        the image being loaded\n * @param  {String}  loadingClass the class to remove\n * @return {Void}\n */\nconst removeLoadingClass = (image, loadingClass) => {\n  let element = image;\n  let shouldReturn = false;\n\n  /*\n   * Since there may be additional elements wrapping the image (e.g. a link),\n   * we run a loop to check the image’s ancestors until we either find the\n   * element with the loading class or hit the `body` element.\n   */\n  while (element.tagName.toLowerCase() !== 'body') {\n    if (element.classList.contains(loadingClass)) {\n      element.classList.remove(loadingClass);\n      shouldReturn = true;\n    } else {\n      element = element.parentNode;\n    }\n\n    if (shouldReturn) {\n      return;\n    }\n  }\n};\n\nconst checkForImagesToLazyLoad = (lazyLoadEvent, images) => {\n  images.forEach((image) => {\n    maybeTriggerImageLoad(image, lazyLoadEvent);\n  });\n};\n\n/**\n * Initializes the lazyloader and adds the relevant classes and handlers.\n * @param  {String}   options.containerClass the lazyloaded image wrapper\n * @param  {String}   options.loadingClass   the class that signifies loading\n * @param  {Function} options.callback       a function to fire on image load\n * @return {Function}                        a function to load visible images\n */\nconst initialize = ({\n  containerClass = 'js--lazyload',\n  loadingClass = 'js--lazyload--loading',\n  callback = false,\n} = {}) => {\n  // Find all the containers and add the loading class.\n  const containers = document.getElementsByClassName(containerClass);\n\n  [].forEach.call(containers, (container) => {\n    container.classList.add(loadingClass);\n  });\n\n  // If we get here, `srcset` is supported and we can start processing things.\n  const images = [].map.call(containers, findImageElement);\n\n  // Create a custom event to trigger the event load.\n  const lazyLoadEvent = new Event('lazyload-init');\n\n  // Attach an onload handler to each image.\n  images.forEach((image) => {\n    /*\n     * Once the image is loaded, we want to remove the loading class so any\n     * loading animations or other effects can be disabled.\n     */\n    image.addEventListener('load', (event) => {\n      removeLoadingClass(event.target, loadingClass);\n\n      // If a callback was provided, fire it.\n      if (typeof callback === 'function') {\n        callback(event);\n      }\n    });\n\n    /*\n     * Set up a listener for the custom event that triggers the image load\n     * handler (which loads the image).\n     */\n    image.addEventListener('lazyload-init', loadImage);\n\n    /*\n     * Check if the image is already in the viewport. If so, load it.\n     */\n    maybeTriggerImageLoad(image, lazyLoadEvent);\n  });\n\n  const loadVisibleImages = checkForImagesToLazyLoad.bind(null, lazyLoadEvent, images);\n\n  /*\n   * Add an event listener when the page is scrolled. To avoid bogging down the\n   * page, we throttle this call to only run every 100ms.\n   */\n  const scrollHandler = throttle(loadVisibleImages, 100);\n  window.addEventListener('scroll', scrollHandler);\n\n  // Return a function to allow manual checks for images to lazy load.\n  return loadVisibleImages;\n};\n\n/**\n * The public function to initialize lazyloading\n * @param  {Object} config configuration options (see `initialize()`)\n * @return {Function}      a function to manually check for images to lazy load\n */\nexport function lazyLoadImages(config = {}) {\n  // If we have `srcset` support, initialize the lazyloader.\n  if ('srcset' in document.createElement('img')) {\n    return initialize(config);\n  }\n}\n\nexport default {\n  lazyLoadImages,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./source/scripts/responsive-lazyload.js"],"sourceRoot":""}